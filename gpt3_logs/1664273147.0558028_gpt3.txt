Summarize the following paper for literature review.


PAPER:
y=f(X). Before the formal denition, we rst introduce two examples. Ex 1 : One example is the task of power allocation to Kusers by a base station (BS), as shown in Fig. 1. In the gure, K= 2, each user and the BS are with a single-antenna, is a permutation matrix to be dened soon. Then, a block in x, sayxk= k, is the scalar channel of thekth user, a block in y, sayyk=pk, is transmit power allocated to the user, and y=f(x) is the power allocation policy. If the users are permutated, then the allocated powers will be permutated correspondingly. Such a policy is 1D permutation invariant to x. Ex 2 : Another example is the task of interference coordination among Ktransmitters by optimizing transceivers, as shown in Fig. 2. Here, a block in X, say xmn= mn2CNtx1, is the channel vector between the mth transmitter (Tx) and the nth receiver (Rx), a block in y, sayyk=pk2RNtx1, is the beamforming vector for the kth user,m;n;k = 1;;K,Ntx January 31, 2020 DRAFT 5 Base StationUser 1 User 2Base StationUser 2 User 1 Permutation  Transformation TT 21 TT 21[ , ] [ , ]pp x y  1 2 T 12 T 12[ , ] [ , ]pp x y 2 1 Fig. 1. Illustration of 1D permutation invariance, power allocation to Kusers, K= 2. is the number of transmit antennas, and y=f(X)is the interference coordination policy. If the Tx-Rx pairs are permutated, then the beamforming vectors are correspondingly permutated. Such a policy is 2D permutation invariant to X. 11 12 21Tx 1 Tx 2Rx 1 Rx 2 Tx 1Tx 2 Rx 1Rx 2 22 Permutation  Transformation T T T 12[ , ] y p p 11 12 21 22 X 22 21 12 11 22 21 T 12 11 X T T T T 21[ , ] y p p Fig. 2. Illustration of 2D permutation invariance, interference coordination among KTx-Rx pairs, K= 2. To dene permutation invariance, we consider a column transformation matrix , which operates on blocks instead of the elements in each block. In other words, the permutation matrix only changes the order of blocks (e.g., xk,ykorxmn) but do not change the order of elements within each block (e.g., the Ntxelements in vector  mn). An example of forK= 3 is, =2 66664I 0 0 0 0 I 0 I 03 77775; where Iand0are respectively the identity matrix and square matrix with all zeros. Denition 1. For arbitrary permutation to x, i.e., Tx= [xT N1;;xT NK]TwhereN1;;NK is arbitrary permutation of 1;;K, ifTy=f(Tx) = [yT N1;;yT NK]T, thenf(x)is 1D permutation invariant to x. January 31, 2020 DRAFT 6 In the following, we provide the sufcient and necessary condition for a function y=f(x) to be 1D permutation invariant. Proposition 1. The function y=f(x)is 1D permutation invariant to xif and only if, yk=  (xk);FK n=1;n6=k(xn) ;k= 1;;K; (2) where(); ()and()are arbitrary functions, and Fis arbitrary operation satisfying the commutative law. Proof: See Appendix A. The operations satisfying the commutative law include summation, product, maximization and minimization, etc. To help understand this condition, consider a more specic class of functions y=f(x)satisfying (2), where the kth block in ycan be expressed as yk=  (xk);KX n=1;n6=k(xn) ;k= 1;;K: (3) Such class of functions y=f(x)are 1D permutation invariant to x. This is because for any permutation of x,~x= [xT N1;;xT NK]T, the solution corresponding to ~xis~y= [~yT 1;;~yT K]T= [yT N1;;yT NK]T, where the kth block of ~yis~yk=( (xNk);PK n=1;n6=Nk(xn)) =yNk. ForEx 1 , the optimal power allocation can be expressed as (3) (though may not be explicitly), where (xk)reects the impact of the kth users channel on its own power allocation, and PK n=1;n6=k(xn)reects the impact of other users channels on the power allocation to the kth user. From (2) or (3) we can observe that: (i) the impact of the block xkand the impact of other blocks xn;n6=konykare different, and (ii) the impact of every single block xn;n6=konyk does not need to be differentiated. This suggests that for a DNN to learn the permutation invariant functions, it should and only need to compose of two types of weights to respectively reect the two kinds of impact. Denition 2. For arbitrary permutation to the columns and rows of X, i.e., TX, ifTy= f(TX), thenf(X)is 2D permutation invariant to X. Using the similar method as in Appendix A, we can prove the following sufcient and necessary condition for a function y=f(X)to be 2D permutation invariant. January 31, 2020 DRAFT 7 Proposition 2. The function y=f(X)is permutation invariant to Xif and only if, yk=  (xkk);FK n=1;n6=k(xkn);GK n=1;n6=k(xnk);HK m;n=1;m;n6=k(xmn) ;k= 1;;K; (4) where();(); ();()and()are arbitrary functions, and F;G;Hare arbitrary operations satisfying the commutative law. Similarly, from (4) we can observe that: (i) the impact of xkk,fxkn;n6=kg,fxnk;n6=kg, fxmn;m;n6=kgonykare different, (ii) the impact of every single block xkn;n6=k(also xnk;n6=kandxmn;m;n6=k) onykdoes not need to be differentiated. ForEx 2 , the optimized solution for a Tx-Rx pair (say p1for the rst pair) depends on the channels of four links: (i) the channel between Tx1 and Rx1  11, (ii) the channels between Tx1 and other receivers  1k;k= 1;;K;k6= 1, (iii) the channels between other transmitters and Rx1 k1;k= 1;;K;k6= 1, and (iv) the channels between all the other transmitters and receivers mn;m;n = 1;;K;m;n6= 1. Their impacts on ykare reected respectively by the four terms within the outer bracket of (4). When Ntx= 1, both mnandpkbecome scalers, while y=f(X)is still 2D permutation invariant to X. B. DNN Architectures for the Tasks with One- and Two-dimensional Permutation Invariance When we design DNNs for wireless tasks such as resource allocation, the essential goal of a DNN is to learn a function y=f(x;W)ory=f(X;W), where xorXandyare respectively the input and output of the DNN, and Wis the model parameters that need to be trained. In what follows, we demonstrate how to construct the architecture of the DNN for the tasks whose policies have the property of 1D or 2D permutation invariance. 1) One-


LITERATURE REVIEW SUMMARY:

==========

This paper discusses the concept of permutation invariance in the context of resource allocation tasks for wireless networks. The paper provides sufficent and necessary conditions for a function to be permutation invariant, and demonstrates how to construct Deep Neural Network (DNN) architectures to learn permutation invariant functions. This is relevant for resource allocation tasks in wireless networks because the order of users or transmitters/receivers should not impact the solution.